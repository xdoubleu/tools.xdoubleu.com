{{template "header"}}
<div class="container-fluid p-3">
  <div class="d-flex justify-content-center align-items-center gap-3 mb-2">
    <span class="text-muted">Room: <strong id="room-code">{{.RoomCode}}</strong></span>
    <a href="/api/auth/signout" class="btn btn-outline-secondary btn-sm">Sign out</a>
  </div>

  <div class="card shadow-sm" style="position:relative;">
    <video id="screenVideo" autoplay playsinline
           style="width:100%; height:90vh; background:#000; object-fit:contain;"></video>

    <video id="selfCam" autoplay playsinline muted
           style="position:absolute; bottom:10px; right:10px; width:18%; border:2px solid #fff;"></video>

    <video id="remoteCam" autoplay playsinline
           style="position:absolute; top:10px; right:10px; width:18%; border:2px solid #fff; display:none;"></video>
  </div>
</div>

<script>
const ROOM = "{{.RoomCode}}";
let ws, pcCam, pcScreen;
let localCam, isSharingScreen=false, remoteCamStream=null;

const selfCamEl = document.getElementById("selfCam");
const remoteCamEl = document.getElementById("remoteCam");
const mainVideoEl = document.getElementById("screenVideo");

function log(...msg){ console.log("%c[VIEWER]", "color:#e67e22", ...msg); }

function send(type, payload, trackType){
    const msg = {type, payload, trackType};
    if(ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg));
    else setTimeout(()=>send(type,payload,trackType),200);
}

function createPC(trackType){
    const pc = new RTCPeerConnection({ iceServers:[{urls:"stun:stun.l.google.com:19302"}] });

    pc.onicecandidate = e => { if(e.candidate) send("candidate", e.candidate, trackType); };
    pc.ontrack = e=>{
        if(trackType==="cam"){
            remoteCamStream = e.streams[0];
            if(isSharingScreen){
                remoteCamEl.srcObject = remoteCamStream;
                remoteCamEl.style.display = "block";
            } else {
                mainVideoEl.srcObject = remoteCamStream;
                remoteCamEl.style.display = "none";
            }
        }
        if(trackType==="screen"){
            isSharingScreen = true;
            mainVideoEl.srcObject = e.streams[0];
            remoteCamEl.srcObject = remoteCamStream;
            remoteCamEl.style.display = "block";
        }
    };
    return pc;
}

// start camera immediately
async function startCamera(){
    localCam = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
    selfCamEl.srcObject = localCam;
    pcCam = createPC("cam");
    localCam.getTracks().forEach(t=>pcCam.addTrack(t, localCam));

    const offer = await pcCam.createOffer();
    await pcCam.setLocalDescription(offer);
    send("offer", offer, "cam");
}

// stop screen share (viewer)
function stopScreen(){
    isSharingScreen=false;
    if(remoteCamStream) mainVideoEl.srcObject = remoteCamStream;
    remoteCamEl.style.display="none";
}

function initWS(){
    ws = new WebSocket(`${location.protocol==="https:"?"wss":"ws"}://${location.host}/watchparty/api/signaling`);
    ws.onopen = ()=>{ ws.send(JSON.stringify({roomCode: ROOM, role:"viewer"})); startCamera(); };
    ws.onmessage = async evt=>{
        const msg = JSON.parse(evt.data);
        if(msg.type==="offer"){
            let pc = msg.trackType==="cam"? pcCam : pcScreen;
            if(!pc) pc = createPC(msg.trackType);
            await pc.setRemoteDescription(msg.payload);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            send("answer", answer, msg.trackType);
        }
        if(msg.type==="answer"){
            let pc = msg.trackType==="cam"? pcCam : pcScreen;
            if(pc && pc.signalingState==="have-local-offer") await pc.setRemoteDescription(msg.payload);
        }
        if(msg.type==="candidate"){
            let pc = msg.trackType==="cam"? pcCam : pcScreen;
            if(pc) await pc.addIceCandidate(msg.payload);
        }
    };
}

initWS();
</script>
{{template "footer"}}
