{{template "header"}}
<div class="container-fluid p-3">
  <div class="d-flex justify-content-center align-items-center gap-3 mb-2">
    <span class="text-muted">Room: <strong id="room-code">{{.RoomCode}}</strong></span>
    <button id="start-screen-btn" class="btn btn-dark btn-sm">Start Screen</button>
    <button id="stop-screen-btn" class="btn btn-outline-danger btn-sm" style="display:none;">Stop Screen</button>
    <a href="/api/auth/signout" class="btn btn-outline-secondary btn-sm">Sign out</a>
  </div>

  <div class="card shadow-sm" style="position:relative;">
    <video id="screenVideo" autoplay playsinline
           style="width:100%; height:90vh; background:#000; object-fit:contain;"></video>

    <video id="selfCam" autoplay playsinline muted
           style="position:absolute; bottom:10px; right:10px; width:18%; border:2px solid #fff;"></video>

    <video id="remoteCam" autoplay playsinline
           style="position:absolute; top:10px; right:10px; width:18%; border:2px solid #fff; display:none;"></video>
  </div>
</div>

<script>
const ROOM = "{{.RoomCode}}";
let ws, pcCam, pcScreen;
let localCam, localScreen;
let isSharingScreen = false;
let remoteCamStream = null;

const selfCamEl = document.getElementById("selfCam");
const remoteCamEl = document.getElementById("remoteCam");
const mainVideoEl = document.getElementById("screenVideo");

function log(...msg){ console.log("%c[PRESENTER]", "color:#4b8bf4", ...msg); }

function send(type, payload, trackType){
    const msg = {type, payload, trackType};
    if(ws.readyState === WebSocket.OPEN){
        ws.send(JSON.stringify(msg));
    } else {
        // buffer messages if WS not ready
        setTimeout(()=>send(type,payload,trackType),200);
    }
}

function createPC(trackType){
    const pc = new RTCPeerConnection({ iceServers:[{urls:"stun:stun.l.google.com:19302"}] });

    pc.onicecandidate = e => { if(e.candidate) send("candidate", e.candidate, trackType); };
    pc.ontrack = e => {
        if(trackType==="cam"){
            remoteCamStream = e.streams[0];
            if(isSharingScreen){
                remoteCamEl.srcObject = remoteCamStream;
                remoteCamEl.style.display = "block";
            } else {
                mainVideoEl.srcObject = remoteCamStream;
                remoteCamEl.style.display = "none";
            }
        }
        if(trackType==="screen"){
            isSharingScreen = true;
            mainVideoEl.srcObject = e.streams[0];
            remoteCamEl.srcObject = remoteCamStream;
            remoteCamEl.style.display = "block";
            document.getElementById("stop-screen-btn").style.display = "inline-block";
        }
    };
    return pc;
}

// start local camera immediately
async function startCamera(){
    localCam = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
    selfCamEl.srcObject = localCam;
    pcCam = createPC("cam");
    localCam.getTracks().forEach(t=>pcCam.addTrack(t, localCam));

    const offer = await pcCam.createOffer();
    await pcCam.setLocalDescription(offer);
    send("offer", offer, "cam");
}

// start screen sharing
async function startScreen(){
    localScreen = await navigator.mediaDevices.getDisplayMedia({video:true,audio:true});
    pcScreen = createPC("screen");
    localScreen.getTracks().forEach(t=>pcScreen.addTrack(t, localScreen));

    const offer = await pcScreen.createOffer();
    await pcScreen.setLocalDescription(offer);
    send("offer", offer, "screen");

    document.getElementById("stop-screen-btn").style.display = "inline-block";
    document.getElementById("start-screen-btn").style.display = "none";

    localScreen.getVideoTracks()[0].onended = stopScreen;
}

// stop screen sharing
function stopScreen(){
    if(!localScreen) return;
    localScreen.getTracks().forEach(t=>t.stop());
    localScreen = null;
    isSharingScreen = false;
    document.getElementById("stop-screen-btn").style.display = "none";
    document.getElementById("start-screen-btn").style.display = "inline-block";

    // main view back to remote camera
    if(remoteCamStream) mainVideoEl.srcObject = remoteCamStream;
    remoteCamEl.style.display = "none";
}

// WebSocket init
function initWS(){
    ws = new WebSocket(`${location.protocol==="https:"?"wss":"ws"}://${location.host}/watchparty/api/signaling`);
    ws.onopen = ()=>{ ws.send(JSON.stringify({roomCode: ROOM, role:"presenter"})); };
    ws.onmessage = async evt=>{
        const msg = JSON.parse(evt.data);
        if(msg.type==="offer"){
            let pc = msg.trackType==="cam"? pcCam : pcScreen;
            if(!pc) pc = createPC(msg.trackType);
            await pc.setRemoteDescription(msg.payload);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            send("answer", answer, msg.trackType);
        }
        if(msg.type==="answer"){
            let pc = msg.trackType==="cam"? pcCam : pcScreen;
            if(pc && pc.signalingState==="have-local-offer") await pc.setRemoteDescription(msg.payload);
        }
        if(msg.type==="candidate"){
            let pc = msg.trackType==="cam"? pcCam : pcScreen;
            if(pc) await pc.addIceCandidate(msg.payload);
        }
    };
}

// initialize
initWS();
startCamera();
document.getElementById("start-screen-btn").onclick = startScreen;
document.getElementById("stop-screen-btn").onclick = stopScreen;
</script>
{{template "footer"}}
